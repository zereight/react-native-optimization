A screenshot of create-react-native-library initialization flow
After answering a few questions, you will be up and running with your new native module that's 
ready for publishing to npm as a third-party dependency to use in consumer apps. However, 
making our code available in the public registry is not always what we want. Sometimes, we 
just want to spin out a custom module specific to our project. Bob makes it possible with the 
local modules functionality by passing the --local flag to the "create" command.
Now, let's explore how to use modern languages for your native modules.
Use modern languages: Swift and Kotlin
Android and iOS have started with different programming languages than they are using today. 
For Android, it was Java, and for iOS, it was Objective-C. 
The successor of Java is Kotlin, created by JetBrains, which took the community by storm 
and, in 2019, was officially announced by Google as a preferred language for building Android 
apps. It's fully interoperable with its predecessor. Except for a few configuration changes, you 
don't need to do anything special to use Kotlin instead of Java. In fact, some parts of React 
Native were rewritten to Kotlin over the last few years, so a library generated by Builder Bob 
already uses Kotlin.
On the iOS side, it's similar but a bit different. Swift originated from within Apple as a next-
generation proprietary language to replace Objective-C in the long run. In 2014, the Swift 
toolchain was released to iOS developers through official Xcode support and soon after made it 
open-source, governed by Apple and Swift community. Swift can easily be used in Objective-C 
codebases and vice versa, allowing incremental migrations. Ever since, together with SwiftUI, it's 
a preferred language for writing iOS apps. The tricky part is its story around C++ interoperability. 
This is important because, with New Architecture, React Native went all in on C++ to ship its 
core cross-platform functionality. There are, however, ways to mitigate that.
Internally, React Native iOS support still heavily depends on Objective-C and its C++ 
interoperability named Objective-C++. Swift, on the other hand, has a very recent and still 
experimental interoperability with C++ but doesn't work the same way as the previous one. 
What we can do in our React Native libraries is to create a small wrapper to bind our calls from 
Objective-C to Swift. It's quite cumbersome, but it works. Let's see how we can do that.
Best Practice: Make Your Native Modules Faster
The Ultimate Guide to React Native Optimization
123